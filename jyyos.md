### 南大os笔记

私以为蒋老师的课精华在于其并发部分

蒋老师前几节课主要是讲程序的构造，大部分与sicp有关，程序就是状态机的模拟，系统调用就是一个指令，能把程序的状态机完全交给操作系统。

#### 对于硬件视角的操作系统

硬件不知道自己运行的是操作系统，只是机械的执行一段指令罢了，cpu遇到问题会进行reset，因此衍生了一种病毒直接把cpu reset后的指令设置成Jmp . 从而导致机器崩溃（偷偷打开硬件写保护），因为我们用的是qemu/bochs实际上跳过了firmware这一部，而这个病毒恰恰是导致firmware出错，这节课还讲了点mbr和bios的知识，不过我之前已经学习过了所以并没有了解太多。

risc-v的操作系统：pc没有规定，寄存器除了x0 全部undifined，但是少数csr有规定，软件可以做的，硬件绝对不管，设计原则就是省电路，而不是x86那种tss给出明确要求，并且还有cr0等寄存器，还有段基址等等

arm： 规定了 cpu reset 但是没有规定设备寄存器的映射，每台机器都看起来不太一样

#### 数学视角的操作系统

程序如何证明正确，一般来讲就是合法的输入对应期望的输出，围绕这个问题衍生出来一些语言，比如proof assistant coq，一般来说都是枚举，自己写一些有代表性的test去证明。

操作系统就是能容纳多个状态机，并且能对状态机进行调控,因此蒋老师创建了一个模型，能进行系统调用，用的彩票调度。

可以通过dfs/bfs模拟以前的状态机，因为操作系统是带来应用不确定的唯一来源，比如cpu把当前进程的时间片换下去等等，而我们可以把操作系统的整个状态机都给模拟出来，确定一些关键性的选择，比如I/O和中断，重现整个计算机系统的执行，即通过虚拟化技术对软件进行自动证明，也就是之前的图灵奖。

#### 并发部分

这一部分是之前的课程，2025年并没有推到这里

最开始的锁是spinlock，spinlock可以在cpu层面直接实现，通过xor就可以，但是这种方法可能会导致cpu发生空转。

![img](https://pica.zhimg.com/50/v2-e5bff3f8a8b62011efe68158eeba7866_720w.jpg?source=2c26e567)

有了这个锁以后我们其实还可以做一点点性能优化，为什么需要优化呢？如果我们上面所说，没有拿到锁的线程就得在那儿自个儿转，反复的读取那块内存空间，看看自己的机会是不是到了。如果说我们明知道这个等待时间是很长的，那就没有必要在那儿反复刷了。我们可以通过操作系统的介入，来实现一个线程向操作系统申请把自己挂起，就是先不刷了，还是把自己挂起，将CPU让出来，这样或许其他的线程能做点更有用的事情。通过这样一种机制构建出来的锁，常常被称为mutex，相当于是在长等待时间上对于自旋锁的一种优化。当然OS切换线程也需要一些开销，所以是否选择被挂起，取决于大概是否需要等很长时间。

但是mutex也有问题，就是mutex会导致syscall，而syscall也会降低性能，也就是说在cpu轮询时间短的情况下spinlock性能不错，但是一旦时间长了mutex表现会更好。

在Linux中，这样的一种锁实现被称为futex，futex的好处就是可以通过判断当前锁的应用场景来决定是mutex还是spinlock，当前效率已经能做到很高很高。