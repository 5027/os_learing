## 1/4

今天一早上起来发现前几天的东西没保存……

#### 45.

这一题我希望用

```
if(max<(nums[i]+i)&&max<nums.size()-1){
​        max=nums[i]+i;
​        count++;
	    }
```

但实际上比如[7,0,9,6,9,6,1,7,9,0,1,2,9,0,3]，（15个），会导致9更新一次，第二个9又更新一次，一直到第三个9能达成目标	

```
class Solution {
public:
  int jump(vector<int>& nums) {
​    int count;
​    int maxpos,n=nums.size(),end=0;
​    for(int i=0;i<n-1;i++){
​      if(maxpos>=i) maxpos=max(maxpos,i+nums[i]);
​      if(i==end){
​        end=maxpos;
​        count++;
​      }
​    }
		 return count;
  }
};
```

这个是标准的解法，我之前又想用双循环（一个用来找起跳点，一个找落点），但是这个for遍历了全部的元素，其实一次就够 了，能优化一个不必要的循环

#### 274

```
for(int i=0;i<n;i++){
​      if(i+1<=citations[i])
​      record= i+1;
​    }
```

这一题很简单，我画了个图想出来的

#### [134. 加油站](https://leetcode.cn/problems/gas-station/)

这题很有意思，同样要用图的思想来解决问题，刚刚洗了个澡想明白了，这一题实际上要找出一个总量为亏损的区间和一个总量一直为盈利的区间，怎么找呢？就要通过sum计算出最低谷，然后从最低谷下一个开始。从开始到最低谷，总量一定是下降的，我们做到的就是把利先吃到手。

#### 42

接雨水，这一题很阴间，用双指针写的话，如果只有左侧一次遍历，则无法考虑到递减的砖块，所以需要右侧也进行遍历，和135有点类似，135发糖果需要遍历两次也是考虑递减的情况。

#### 13

罗马转整数，这一题通过检测右边是不是比左边大就可以知道是-还是+了

#### 12 

贪心求解，最好用最大的数去表示

#### 14

假设第一个为最长公前缀，如果不是就逐步削减。

也可以通过直接字符串排序（字典序排序）然后对比第一个和最后一个的前缀

#### ?. 

又写了一个反转单词的，先以words单位读入到vec中，反转加空格

#### [6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

把每一行都抽象成一个数组就能写了,然后根据顺序添加到对应的数组

#### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

双指针移动条件没搞明白

最大水量=Math.min(height[left],height[right])*长度，往中间移动长度一定会变短

如果移动高的那一边，会有两种情况：

1、下一根柱子的高度比现在高，高度还取最小值低的那边，最大水量比原来小

2、下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小

如果移动低的那一边，会有两种情况：

1、下一根柱子的高度比现在高，高度就可以取更高的值，最大水量不一定比原来小

2、下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小

所以应该移动低的那一边

#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

我最开始想出了排序，，，然后想搞个三指针，实际上这一题让nums[i]+nums[j]=- nums[k]就可以变形成双指针了